#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <fstream> // allows to read and write .txt files
#include <cmath>
#include <iomanip>
#include <cstddef>
#include <csignal>
#include <cstdio>
#include <ctime> // for time
#include <string>
#include <cctype>
#include <vector>
#include <sstream>
#include <algorithm>
#include <set>
//#include <unistd.h> //for usleep in linux 
#include <windows.h> //for sleep in windows

#define RESET   "\033[0m"
#define RED     "\033[31m"      /* Red */
#define BLUE    "\033[34m"      /* Blue */

using namespace std;

//----------------------------------------------------------------------------------------------------
/*
The player class allows the entry of several characteristics of the game, such as the name of the players,
disk color, disk symbol, game mode (), AI difficulty in case of playing against pc */
//----------------------------------------------------------------------------------------------------
class player
{
public:
	player(int player_number, string symbol, string player_type);
	void InputName(); //To set the players name
	string GetName();
	int GetNumber();
	string GetSymbol();
	string GetColour();
	string GetPlayerType();
	void SetPlayerType(string type); //computer or human

private:
	int player_number; // 1 or 2
	string name;
	string symbol; // 'X' or 'O'
	string colour; // 'red' or 'blue'
	string player_type; // "Human", "Computer_Easy", "Computer_Medium", "Computer_Hard"
	
};
//----------------------------------------------------------------------------------------------------
player::player(int player_number, string symbol, string player_type)
{/*
Player class constructor: It has the parameters player_number (related to the player number in the game i.e. player 1 and player 2),
symbol (related to the game pieces "X" and "O") , player_type (related to the type of game, i.e. , Player VS Player or Player VS Computer).
*/
	this->player_number = player_number;
	this->symbol = symbol;
	this->player_type = player_type;
	this->name = "";

	if (symbol == "X")
		this->colour = RED;
	else if (symbol == "O")
		this->colour = BLUE;
}
//----------------------------------------------------------------------------------------------------
void player::InputName()
{/*
This function defines player names based on their ID i.e. player 1 or 2.
If is Player VS Computer, get just the name of the player.
*/
	if (this->player_type == "Human")
	{
		int ID = this->player_number;
		cout << "\nPlayer" << ID << ", write your name: ";
		cin >> this->name;
		cout << "\nPlayer" << ID << ":" << this->name << endl;
	}

	else
	{
		this->name = this->player_type;
		cout << "\nPlayer" << this->player_number << ":" << this->name << endl;
	}

}
//----------------------------------------------------------------------------------------------------
int player::GetNumber()
{/*Return the player number (1 or 2).
*/
	return this->player_number;
}
//---------------------------------------------------------------------------------------
string player::GetColour()
{/*Return the Color (Red or Blue).
*/
	return this->colour;
}
//---------------------------------------------------------------------------------------
string player::GetSymbol()
{/* Return the symbol ("X" or "O").
*/
	return this->symbol;
}
//---------------------------------------------------------------------------------------
string player::GetName()
{/* Return the Players Name.
*/
	return this->name;
}
//---------------------------------------------------------------------------------------
string player::GetPlayerType()
{/* Return the Game Type (Player VS Player or Player VS Computer).
*/
	return this->player_type;
}
//---------------------------------------------------------------------------------------
void player::SetPlayerType(string type)
{/* Receives the method "type" and references the player_type attribute (The "type" can be "Computer_Easy" or "Human", set in player Menu).
*/
	this->player_type = type;
}
//-----------------------------------------------------------------------------------------------
player Menu(player Enemy_player)
{/* This function receives the "Enemy_Player" defined in the auxiliary function "void Game" as a method.
It aims to define the game mode (Player VS Computer | Player VS Player) through the input of the player(s).
If it is the 1st option, it also defines the difficulty of the game against the AI (it can be easy, medium or hard).*/

	string GameMode = "";
	string PlayerVSPlayer = "1";
	string PlayerVSComputer = "2";
	string AI_Easy = "1";
	string AI_Medium = "2";
	string AI_Hard = "3";

	//1st Part: Choose the type of Game Mode
	while (true)
	{
		cout << "How many people are playing?\n(1-Player VS Computer | 2-Player VS Player): ";
		cin >> GameMode;
		cout << endl;

		if (GameMode == PlayerVSPlayer)
		{
			Enemy_player.SetPlayerType("Computer_Easy");
			break;
		}
		else if (GameMode == PlayerVSComputer)
		{
			Enemy_player.SetPlayerType("Human");
			break;
		}
		else
			cout << "Error! You must input 1 or 2." << endl;
	}

	//2nd Part: Select Game Difficulty, in case of Player VS Computer
	if (Enemy_player.GetPlayerType() != "Human")
		while (true)
		{
			cout << "How difficult do you want the game to be?\n(1-Easy | 2-Medium | 3-Hard) ";
			cin >> GameMode;

			if (GameMode == AI_Easy)
			{
				Enemy_player.SetPlayerType("Computer_Easy");
				break;
			}

			else if (GameMode == AI_Medium)
			{
				Enemy_player.SetPlayerType("Computer_Medium");
				break;
			}

			else if (GameMode == AI_Hard)
			{
				Enemy_player.SetPlayerType("Computer_Hard");
				break;
			}

			else
				cout << "Error! You must input 1 , 2 or 3." << endl;
		}

	return Enemy_player;

}

//----------------------------------------------------------------------------------------------------
/*Class Board represents the game board, allowing to define the limits of the board, 
and to place the disk in the column chosen with the color of the respective player.
Defines the winner of the game and allows the artificial intelligence to play.
*/
class Board
{
private:
	//represents the lowest empty row (to play on that when choosing that column, so you don't have to search the rows above)
	vector <char> ColumnLegend; //column
	vector< vector<string>> board; //board
	int numL, numC, numN; //number of lines, coloumn and number of sequence to win.
	string emptySymbol; //flexibilidade do que é considerado espaço vazio no tabuleiro.
	int numEmptyCells; //(fica - 1 a cada jogada.Ao chegar a zero, declara empate se ninguém tiver dado.)
	string headline_displayed;
	string headline; //headline of the board defines from player
	string winnerSequence1;
	string winnerSequence2;
	int NumberOfBoardCells = numC * numL; //How many cells there are on board
	int HighestDimension = max(numC, numL);
	int LowestDimension = min(numL, numC);

	//Save the line and column of the last move (search for a winner, starting from that position)
	string LastDiscSymbol;
	
	int AI_selectedColumn;
	//Save LastDiscSymbol(search only last winner character)
public:
	//public variables
	vector <int> topline;
	int LastLinePlayed, LastColumnPlayed;

	Board(int numL, int numC, string emptySymbol, int numN);
	string buildSequence(int numN, string symbol);
	void SetEmptySymbol();
	int GetNumLines() const;
	int GetNumColumns() const;
	string	GetEmptySymbol() const;
	void Headline();
	int	GetTopLineIndexAtColumn();
	//int SetTopLine() const;
	int SelectColumn(player player);
	void putDiscAtColumn(player player); //in a certain column
	string isFull(int NumberOfPlays, int NumberOfBoardCells) const; //test if board is full
	void show() const; //show board
	string isThereAWinner(); //shows winner symbol, and last move row and column.
	void wouldThereBeAWinner(); //putDisc + winner? (p/ AI) 
	//(pode estar numa classe complementar - Classe Game : encarregar - se de ver conteúdo, verificar vencedor
	void AIPlay(class player player);

};
//--------------------------------------------------------------------------------------
Board::Board(int numL, int numC, string emptySymbol, int numN)
{/*Board class constructor: It has the parameters numL (related to how many lines the board has),
numC (related to how many columns the board has) , emptySymbol (related to the symbol the board has - "." ),
numN (related to how many consecutive symbols are needed to win).
*/
	this->numL = numL;
	this->numC = numC;
	this->emptySymbol = emptySymbol;

	this->winnerSequence1 = buildSequence(numN, "X");
	this->winnerSequence2 = buildSequence(numN, "O");

	this->topline = vector<int>(numC, numL);
	this->board = vector <vector<string>>(numL, vector<string>(numC, emptySymbol));
}
//--------------------------------------------------------------------------------------
string Board::buildSequence(int numN, string symbol)
{/* Function to create a sequence of symbols according to what was previously requested 
by the player as a sequence number to win
*/
	string sequence = symbol;
	for (int i = 0; i < numN - 1; i++)
	{
		sequence = sequence + symbol;
	}
	return sequence;
}
//--------------------------------------------------------------------------------------
void Board::SetEmptySymbol()
{ /* This function has the objective of defining the symbol to be used in the game, 
for that it asks the player to choose the types of symbols between 1. . , 2.[], 3._ 
*/

    //default empty symbol is '.'
	int choose_emptysymbol;
	cout << "Choose the empty symbol you would prefer to see: 1. . , 2.[], 3._" << endl;
	cin >> choose_emptysymbol;

	string emptySymbol;

	switch (choose_emptysymbol)
	{
	case (1):
		emptySymbol = ".";
	case(2):
		emptySymbol = "[]";
	case (3):
		emptySymbol = "_";
	case (4):
		;
		//Player chooses emptySymbol
	default:
		emptySymbol = ".";
	};
}
//--------------------------------------------------------------------------------------
int Board::GetNumLines() const
{/*Return how many lines the board has (Between 6 and 10).
*/
	return this->numL;
}
//--------------------------------------------------------------------------------------
int Board::GetNumColumns() const
{/*Return how many columns the board has (Between 6 and 10).
*/
	return this->numC;
}
//--------------------------------------------------------------------------------------
string Board::GetEmptySymbol() const
{/*Return the symbol that board has (Defaut: ".").
*/
	return this->emptySymbol;
}
//----------------------------------------------------------------------------------------------------
int Board::GetTopLineIndexAtColumn()
{ /* Function used to find the line where the disc will be placed.
At the start of the game, topline has numC elements equal to numL-1. Every time a disc is inserted,
the value saved for that corresponding column decreases by 1. Hence, if we play in the same column again, we will play in a line higher by 1,
When the value is 0, it will play at the top of the column. When the value is -1, the column is full.
*/
// after every play: 
	int ColumnHeight = topline.at(LastColumnPlayed);
	this->LastLinePlayed = ColumnHeight - 1;
	topline.at(LastColumnPlayed) = this->LastLinePlayed;
	return this->LastLinePlayed;
}

//-----------------------------------------------------------------------------------------------
int Board::SelectColumn(player player)
{/* Function for the player to select the column where wants to place the disc.
The PlayerName is defined with the function GetName and the PlayerType with the function GetPlayerType, both of the Player Class.
If the PlayerType is "Human", the player must select the column where wants to place the piece.
The function still has the ability to prevent invalid entries, and the ability to turn lowercase letters into uppercase */

	string InputedColumn = "";
	string PlayerName = player.GetName(); //get the name of the player(s)
	string PlayerType = player.GetPlayerType(); //get the Player Type ("Human" or "AI")
	int Not_found = -1;
	int PossibleColumnSelected = -1;
	string IsColumnValid = "Invalid";

	if ((PlayerType == "Human"))
	{
		while (IsColumnValid == "Invalid")
		{
			cout << "\n" << PlayerName << ", in which column, do you want to insert your piece?" << endl;
			cin >> InputedColumn;

			if ((InputedColumn.size() != 1)) // it ensures that the input is only one letter, testing whether its size is equal to or different from 1.
				InputedColumn = "_"; //in this case, it will not detect the value in the headline and will output an error

	
			if (int(InputedColumn[0]) > int('Z')) // it ensures that lowercase is converted to uppercase
				InputedColumn[0] = char(int(InputedColumn[0]) - 32);

			PossibleColumnSelected = int(headline.find(InputedColumn[0]));
			PossibleColumnSelected = PossibleColumnSelected;

			if (PossibleColumnSelected == Not_found) // it ensures that the checked inputed_column is in the headline
				cout << "\nError! You must insert a valid input." << endl;

			else //if the value is valid
			{
				int ColumnHeight = topline.at(PossibleColumnSelected);
				if (ColumnHeight <= -1) //if top is reached, must play another column.
					cout << "\nAttention! Column is full, choose another." << endl;

				else //column is valid, while loop stops
					IsColumnValid = "Valid";
			}
		}
	}
	else //when the player_type is AI
		PossibleColumnSelected = AI_selectedColumn;

	int LastColumnPlayed = PossibleColumnSelected;
	this->LastColumnPlayed = LastColumnPlayed;
	return LastColumnPlayed;
}
//-----------------------------------------------------------------------------------------------
void Board::putDiscAtColumn(player player)
{	//This function works for both (AI and Player) and puts the disc at a column selected before. 

	this->LastLinePlayed = GetTopLineIndexAtColumn();
	/*cout << "LastCol Played:" << LastColumnPlayed;
	cout << "LastLine Played:" << LastLinePlayed;*/

	this->LastDiscSymbol = player.GetSymbol();
	board.at(LastLinePlayed).at(LastColumnPlayed) = LastDiscSymbol;

}
//-----------------------------------------------------------------------------------------------
string Board::isFull(int NumberOfPlays, int NumberOfBoardCells) const
{/*
This function checks whether the board is full or not based on inputs of the number of moves and 
the number of cells on the board. If the number of moves is the same as the number of cells on the board,
will return that it is full and thus the game ends in a tie.
*/
	string isThereATie = "There is no tie";

	if (NumberOfPlays == NumberOfBoardCells)
		isThereATie = "It's a Tie!";

	return isThereATie;
}
//-----------------------------------------------------------------------------------------------
void Board::Headline()
{/*Function that creates the header and footer of the game based on the size of the board defined by the player.
Even knowing that the maximum size of the board is 10x10, it would be possible to make it bigger, since the 26 letters of the alphabet were defined.
*/
	int spacePerLetter = 3; //space occupied per Letter
	const string alphabet_w_spaces = " A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z";
	string headline_displayed = alphabet_w_spaces.substr(0, spacePerLetter * GetNumColumns()); //creates substring, according to the number of columns in the board. 
	this->headline_displayed = headline_displayed;

	const string alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	string headline = alphabet.substr(0, GetNumColumns()); //creates substring, according to the number of columns in the board. 
	this->headline = headline;
}
//-----------------------------------------------------------------------------------------------
void Board::show() const
{/* Function to show the board.
This function creates two iterator based on two vectors that were previously defined in the board constructor.
At the end, the board is shown with the correct dimensions and also with the headline.
*/
	cout << headline_displayed << endl;

	// Iterator for the 2-D vector
	vector<vector<string>>::iterator it1;

	// Iterator for each vector inside the 2-D vector
	vector<string>::iterator it2;

	vector<vector<string>> show_board = board;

	// Traversing a 2-D vector using iterators
	for (it1 = show_board.begin(); it1 != show_board.end(); it1++) {
		for (it2 = it1->begin(); it2 != it1->end(); it2++)
			cout << " " << *it2 << " ";
		cout << endl;
	}

	cout << headline_displayed << endl;;

}

//-----------------------------------------------------------------------------------------------
string Board::isThereAWinner()
{ /* function that checks the chances of winning the game
*/
	//checking for horizontal win:
	//string lineWin = "";
	//for (int lin = 0; lin < GetNumLines() - 1; lin++)

	int possibleHorizontalWins = 0;
	int possibleVerticalWins = 0;
	int possibleNegativeDiagonalWins = 0; // (\)
	int possiblePositiveDiagonalWins = 0; // (/)
	string linWin = "";
	string ColWin = "";
	string NegativeDiagonalWin = "";// (\)
	string PositiveDiagonalWin = "";// (/)

	int NotFoundInStr = string::npos;

	// Iterator for each vector inside the 2-D vector
	vector<string>::const_iterator horizontal_it;

	//horizontal_it = board[lin].begin();

		// Vitória horizontal
	for (int lin = 0; lin < numL; lin++)
	{
		for (horizontal_it = board[lin].begin(); horizontal_it != board[lin].end(); horizontal_it++)
		{
			linWin = linWin + *horizontal_it;
		}
		//cout << "linWin: " << linWin << endl;

		if (linWin.find(winnerSequence1) == NotFoundInStr && linWin.find(winnerSequence2) == NotFoundInStr) //when player2 hasn't won and when player1 hasn't won
			possibleHorizontalWins = 0;
		else if (linWin.find(winnerSequence1) != NotFoundInStr) //player1 has won
		{
			possibleHorizontalWins = 1;
			break;
		}
		else if (linWin.find(winnerSequence2) != NotFoundInStr) //player2 has won
		{
			possibleHorizontalWins = -1;
			break;
		}

		linWin = ""; //cleaning after each iteration
	}
	//cout <<"Horizontal win: " << possibleHorizontalWins << endl;;
	//cout << "linWin: " << possibleHorizontalWins;

	// Iterator for the 2-D vector
	vector<vector<string>>::const_iterator vertical_it;

	vector<string> boardLine;
	boardLine = vector <string>(numC, "");

	// Vitória vertical
	for (int col = 0; col < numC; col++)
	{
		for (vertical_it = board.begin(); vertical_it != board.end(); vertical_it++)
		{
			boardLine = *vertical_it; //analyses each line of the board and takes the 1st element, forming the 1st column. Keeps going for every column. 
			ColWin = ColWin + boardLine.at(col);

		}
		/*cout << "vertical find win seq1: " << ColWin.find(winnerSequence1) << endl;
		cout << "not found: " << NotFoundInStr <<endl;
		cout << "not found: " << (NotFoundInStr == ColWin.find(winnerSequence1)) << endl;*/

		if (ColWin.find(winnerSequence1) == NotFoundInStr && ColWin.find(winnerSequence2) == NotFoundInStr) //when player2 hasn't won and when player1 hasn't won
			possibleVerticalWins = 0;
		else if (ColWin.find(winnerSequence1) != NotFoundInStr) //player1 has won
		{
			possibleVerticalWins = 1;
			break;
		}
		else if (ColWin.find(winnerSequence2) != NotFoundInStr) //player2 has won
		{
			possibleVerticalWins = -1;
			break;
		}

		cout << "Vertical win: " << possibleVerticalWins << endl;
		ColWin = ""; //cleaning
	}

	//PositiveDiagonalWin PossiblePositiveDiagonalWin
	// Vitória diagonalLeftToRight (/)

	for (int col = 0; col < numC; col++)
	{
		for (int lin = 0; lin < numL; lin++)
		{
			for (int i = 0; i < HighestDimension; i++)
			{
				if ((lin + i < numL) && (col - i < numC))
					PositiveDiagonalWin = PositiveDiagonalWin + board.at(lin + i).at(col + i);
				else
					if (PositiveDiagonalWin.find(winnerSequence1) == NotFoundInStr && PositiveDiagonalWin.find(winnerSequence2) == NotFoundInStr) //when player2 hasn't won and when player1 hasn't won
						possiblePositiveDiagonalWins = 0;
					else if (PositiveDiagonalWin.find(winnerSequence1) != NotFoundInStr) //player1 has won
					{
						possiblePositiveDiagonalWins = 1;
						break; break; break;
					}
					else if (PositiveDiagonalWin.find(winnerSequence2) != NotFoundInStr) //player2 has won
					{
						possiblePositiveDiagonalWins = -1;
						break; break; break;
					}

				break;
			}
		}

		cout << "PositiveDiag : " << PositiveDiagonalWin << endl;

		if (PositiveDiagonalWin.find(winnerSequence1) == NotFoundInStr && PositiveDiagonalWin.find(winnerSequence2) == NotFoundInStr) //when player2 hasn't won and when player1 hasn't won
			possiblePositiveDiagonalWins = 0;
		else if (PositiveDiagonalWin.find(winnerSequence1) != NotFoundInStr) //player1 has won
		{
			possiblePositiveDiagonalWins = 1;
			break;
		}
		else if (PositiveDiagonalWin.find(winnerSequence2) != NotFoundInStr) //player2 has won
		{
			possiblePositiveDiagonalWins = -1;
			break;
		}
		PositiveDiagonalWin = "";
	}

	cout << "Positive diag win if 1: " << possiblePositiveDiagonalWins;

	//NegativeDiagonalWin possibleNegativeDiagonalWin
	// Vitória diagonalRightToLeft (\)

	for (int col = 0; col < numC; col++)
	{
		for (int lin = 0; lin < numL; lin++)
		{
			for (int i = 0; i < HighestDimension; i++)
			{
				if ((lin + i < numL) && (col + i >= 0))
				{
					NegativeDiagonalWin = NegativeDiagonalWin + board.at(lin + i).at(col + i);
				}
				else
					if (NegativeDiagonalWin.find(winnerSequence1) == NotFoundInStr && NegativeDiagonalWin.find(winnerSequence2) == NotFoundInStr) //when player2 hasn't won and when player1 hasn't won
						possibleNegativeDiagonalWins = 0;
					else if (NegativeDiagonalWin.find(winnerSequence1) != NotFoundInStr) //player1 has won
						possibleNegativeDiagonalWins = 1;
					else if (NegativeDiagonalWin.find(winnerSequence2) != NotFoundInStr) //player2 has won
						possibleNegativeDiagonalWins = -1;

				NegativeDiagonalWin = "";
				cout << "NegDiag: " << NegativeDiagonalWin << endl;
				cout << "NegDiag win: " << possiblePositiveDiagonalWins << endl;
				break;
			}
		}
	}
	cout << "Neg diag win if 1: " << possibleNegativeDiagonalWins;

	string winner = "";

	if ((possibleNegativeDiagonalWins == -1) || possiblePositiveDiagonalWins == -1 || possibleVerticalWins == -1 || possibleHorizontalWins == -1)
	{
		winner = "IsWinner";
		return winner;
	}


	else if (possibleNegativeDiagonalWins == 1 || possiblePositiveDiagonalWins == 1 || possibleVerticalWins == 1 || possibleHorizontalWins == 1)
	{
		winner = "IsWinner";
		return winner;
	}

	else
	{
		winner = "No Winner Yet";
		return winner;
	}
	cout << "Total Win: " << winner << endl;
}
//-----------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------
void Board::wouldThereBeAWinner()
{
	vector < vector <string> > test_board = board;

	for (int col = 0; col < numC; col++)
	{
		int lin = GetTopLineIndexAtColumn();
		test_board.at(lin).at(col) = "X";
		//string isThereAWinnerResult= isThereAWinner(test_board);
	}
}
//-----------------------------------------------------------------------------------------------
void Board::AIPlay(class player player)
{/* function for artificial intelligence with different levels of difficulty
*/
	//wouldThereBeAWinner(); playerSymbol = "O"
	string AIlevel = player.GetPlayerType();
	
	Board test_board = Board(numL, numC, emptySymbol, numN);
	vector < vector <string> > original = test_board.board;


	int HighestDimension = max(numC, numL);
	double counting_points = 0;
	double counting_symbols = 0;
	string winner = ""; // "winner", "not winner"
	int NotFoundInStr = string::npos;

	string ComputerSymbol = "O";
	string HumanSymbol = "X";
	string emptySymbolStr = "";
	bool change = false;
	int AI_move = 1;
	// AI Easy - Places pieces randomly.
	if (AIlevel == "Computer_Easy")
	{
		// AI_move = min + (rand() % (int)(max - min + 1)) / min=0 e max=numC
		AI_move = rand() % (int)(numC); //random number between 0 and numC
		while (topline.at(AI_move) == -1)
		{
			int AI_move = rand() % (int)(numC + 1);
		}
		//string symbol= "O";
		this->AI_selectedColumn = AI_move;
		//test_board.board.at(topline.at(AI_move)).at(AI_move) = "O";

	}

	// AI Medium - Plays most of the time randomly, except when the AI can get a win or stop the opponent for winning. 
	else if (AIlevel == "Computer_Medium")
	{
		// Insert a piece in every column of the test_board, a copy of the original board.
		for (int i = 0; i < numC; i++)
		{

			if (topline.at(i) != -1)
			{
				test_board.board.at(topline.at(i)).at(i) = "O";
				winner = test_board.isThereAWinner();
				test_board.board = original;

				if (winner == "isWinner")
					this->AI_selectedColumn = i;  break;

				test_board.board.at(topline.at(i)).at(i) = "X";
				winner = test_board.isThereAWinner();
				test_board.board = original;

				if (winner == "isWinner")
					this->AI_selectedColumn = i; break;

			}


		}


		AI_move = rand() % (int)(numC); //random number between 0 and numC
		while (topline.at(AI_move) == -1)
		{
			int AI_move = rand() % (int)(numC);
		}
		//string symbol= "O";
		this->AI_selectedColumn = AI_move;

	}

}
//-----------------------------------------------------------------------------------------------//-----------------------------------------------------------------------------------------------
/*End of Class player.
Start of Functions to help play the game*/
//-----------------------------------------------------------------------------------------------
int SetNumLines()
{/*Function to set the number of lines on the board. The player will have the option to enter a value between 6 and 10.
A bool function was also made for inputs of only integers and between the previously defined range.
*/

	int numL = 0;
	string numLStr = "";
	while (numL < 6 || numL > 10)
	{
		cout << "Please, set the dimensions of the board (Minimum dimension: 6x6, Maximum dimension: 10x10). Number of Lines: "; 
		cin >> numLStr;

		bool isInt = (numLStr.find_first_not_of("0123456789") == std::string::npos); //it guarantees the entry of only integers


		if (isInt == true)
			numL = stoi(numLStr); //convert string to integer

		if (numL < 6 || numL > 10) //it guarantees the entry of values betwwen 6 and 10.
		{
			cout << "Invalid Number of Lines, must be between 6 and 10!! \n";
		}
	}
	return numL;
}
//-----------------------------------------------------------------------------------------------
int SetNumColumns()
{/*Function to set the number of columns on the board. The player will have the option to enter a value between 6 and 10.
A bool function was also made for inputs of only integers and between the previously defined range.
*/
	int numC = 0;
	string numCStr = "";
	while (numC < 6 || numC > 10)
	{
		cout << "Number of Columns: ";
		cin >> numCStr;

		bool isInt = (numCStr.find_first_not_of("0123456789") == std::string::npos); //it guarantees the entry of only integers


		if (isInt == true)
			numC = stoi(numCStr); //convert string to integer


		if (numC < 6 || numC > 10) //it guarantees the entry of values betwwen 6 and 10.
		{
			cout << "Invalid Number of Columns, must be between 6 and 10!! \n";
		}
	}
	return numC;
}
//-----------------------------------------------------------------------------------------------
int SetConditionsForWinner(int numL, int numC)
{/*Function to set how many consecutive symbols are needed to win. 
    The player will have the option to enter a value greater than or equal to 4.
    A bool function was also made for inputs of only integers and between the previously defined range.
    */
	int numN = 0;
	string numNStr = "";

	while (numN < 4 || numN> max(numC, numL))
	{
		cout << "Please, choose how many consecutive symbols are needed to win (Minimun = 4):  ";
		cin >> numNStr;

		bool isInt = (numNStr.find_first_not_of("0123456789") == std::string::npos); //it guarantees the entry of only integers


		if (isInt == true)
			numN = stoi(numNStr); //convert string to integer

		if (numN < 4 || numN> max(numC, numL)) //it guarantees the entry of values betwwen 4 and the maximum number of a column/line.
		{
			cout << "Invalid Condition!! \n";
		}
	}
	return numN;
}
//-----------------------------------------------------------------------------------------------
char time()
{/* Function to save game start date and time.
*/
	time_t t;
	struct tm* infoTime;
	char DayTime[20]; //Where the time information will be saved.

	time(&t);
	infoTime = localtime(&t); //Get the time 

	strftime(DayTime, 20, "%F / %R", infoTime); //Creates the Day and Time with the following format YYYY/MM/DD / HH:MM

	return DayTime[20];
}
//-----------------------------------------------------------------------------------------------
void GameEnd(player player1, player player2, string winnerInfo)
{/*Function to save game data in txt.
*/
	cout << "Game Has Ended " << winnerInfo << endl;
	ofstream file;
	file.open("winner.txt");// Creates the file 

	// Writes the winner and the time in file in following format: 2022-10-15 / 09:05 – 1)computador vs 2)Pedro Costa – vencedor: 2.
	file << time();
	file << " - 1)" << player1.GetName() << " vs 2)" << player2.GetName() << " - vencedor: " << winnerInfo << "\n";
	file.close(); // Close file

	cout << "Saving to the file..." << endl;
	unsigned sleep(2); //Sleep the system for 2s 
	cout << "Thanks for playing, bye :) !! " << endl;

}
//-----------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------
void Game()
{	//Players' Set-Up
	player player1 = player(1, "X", "Human");
	player player2 = player(2, "O", "Human");
	player2 = Menu(player2); //Menu() - asks player game mode, level of difficulty
	player1.InputName(); //asks players' name 
	player2.InputName();

	//Board Set-Up
	int numL = SetNumLines(); //user chooses board size
	int numC = SetNumColumns();
	int numN = SetConditionsForWinner(numL, numC); //user chooses winner length sequence

	string emptySymbol = ".";

	Board board = Board(numL, numC, emptySymbol, numN);

	//board.SetEmptySymbol(); //user chooses empty symbol - está estranho!

	int NumberOfBoardCells = numL * numC;
	int NumberOfPlays = 0;
	string winnerInfo = {};
	string GameResult = "No Winner Yet";
	player playerPlaying = player1; //player1 starts
	string strPlayerPlaying = "player1";
	board.Headline(); //prepares board headline
	board.show(); //shows board with headline directly above and below

	//Game Start
	while (true)
	{
		int LastColumnPlayed = board.SelectColumn(playerPlaying); //player chooses column

		if (player2.GetPlayerType() != "Human")
			board.AIPlay(player2);

		board.putDiscAtColumn(playerPlaying);
		NumberOfPlays = NumberOfPlays + 1;
		board.show();
		GameResult = board.isThereAWinner(); //tests if there is a winner
		//cout << "GameResult:" << GameResult;

		if (GameResult == "IsWinner")
		{
			winnerInfo = strPlayerPlaying;
			cout << "Test- Is Winner";
			GameEnd(player1, player2, winnerInfo); //game ends
			break;
		}

		else //when there is no winner yet
		{
			string IsThereATie = board.isFull(NumberOfPlays, NumberOfBoardCells);

			if (IsThereATie == "It's a Tie!") //checks for tie
			{
				cout << "Test- Is Tie";
				winnerInfo = "Empate, não há vencedor.";
				GameEnd(player1, player2, winnerInfo); //game ends
				break;
			}

			else //if there is no tie, game keeps going: players switch turns
			{
				cout << "PlayerPlaying" << strPlayerPlaying;

				if (strPlayerPlaying == "player1")
				{
					strPlayerPlaying = "player2"; //switches player
					playerPlaying = player2;
				}
				else if (strPlayerPlaying == "player2")
				{
					strPlayerPlaying = "player1";  //switches player
					playerPlaying = player1;

				}
			}
		}
	}
}
//-----------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------
int main()
{
	srand(unsigned(time(NULL)));
	Game(); //Function game stars
	return 0;
}


/*


////
// 
//  (not working)
//  AI Hard - Plays most of the time randomly, except when the AI can get a win or stop the opponent for winning. 
//		else if (AIlevel == "Computer_Hard")
//		{
//
//
//
//
//		change = false;
//
//		for (int i = 0; i < numC; i++)
//		{
//			test_board.at(topline.at(i)).at(i) = ComputerSymbol;
//			string winner = board.isThereAWinner(test_board);
//			test_board.at(topline.at(i)).at(i) = emptySymbol;
//
//			if (winner == "Player2")
//				board.at(topline.at(i)).at(i) = ComputerSymbol; change = true; break;
//
//			test_board.at(topline.at(i)).at(i) = "X";
//			string winner = board.isThereAWinner(test_board);
//			test_board.at(topline.at(i)).at(i) = emptySymbol;
//
//			if (winner == "Player1")
//				board.at(topline.at(i)).at(i) = "O"; change = true; break;
//
//
//		}
//
//		if (change == false)
//		{
//
//			for (int i = 0; i < winnerSequenceLength; i++)
//				emptySymbolStr = emptySymbolStr + emptySymbol;
//
//			string combination_human = emptySymbolStr;
//			string combination_computer = emptySymbolStr;
//
//
//			vector<string> all_combinations_computer{};
//			vector<string> all_combinations_human{};
//
//
//			int counter = 1;
//			while (counter <= winnerSequenceLength)
//			{
//				for (int i = 0; i < counter; i++)
//				{
//					combination_computer.at(i) = ComputerSymbol[0];
//					combination_human.at(i) = HumanSymbol[0];
//				}
//
//				all_combinations_computer.push_back(combination_computer);
//				all_combinations_human.push_back(combination_human);
//
//				for (int j = 0; j + counter < winnerSequenceLength; j++)
//				{
//					combination_computer.at(j + counter) = ComputerSymbol[0];
//					combination_computer.at(j) = emptySymbol[0];
//
//					combination_human.at(j + counter) = HumanSymbol[0];
//					combination_human.at(j) = emptySymbol[0];
//
//					all_combinations_computer.push_back(combination_computer);
//					all_combinations_human.push_back(combination_human);
//
//
//				} //XXXXX. .XXXXX
//
//				combination_human = emptySymbolStr;
//				combination_computer = emptySymbolStr;
//
//				counter++;
//			}
//
//			reverse(all_combinations_computer.begin(), all_combinations_computer.end());
//
//			reverse(all_combinations_human.begin(), all_combinations_human.end());
//
//
//			//vector <string> combinations = ;
//
//			// if winnerSequenceLength == 6;
//			// XX.... | .XX... | ..XX..  | ...XX. | ....XX
//			// XXX... | .XXX.. | ..XXX.  | ...XXX
//			// XXXX.. | .XXXX. | ..XXXX
//			// XXXXX. | .XXXX
//
//			//string verticalStrWithoutExtraPiece = "";
//			string verticalStr = "";
//			string verticalPossibleHumanPlayStr = "";
//
//			//string horizontalStrWithoutExtraPiece = "";
//			string horizontalStr = "";
//			string horizontalPossibleHumanPlayStr = "";
//
//			//string positiveDiagonalStrWithoutExtraPiece = ""; // (/)
//			string positiveDiagonalStr = ""; // (/)
//			string positiveDiagonalForwardStr = "";
//			string positiveDiagonalBackwardStr = "";
//
//			string positiveDiagonalPossibleHumanPlayStr = ""; // (/)
//			string positiveDiagonalForwardPossibleHumanPlayStr = "";
//			string positiveDiagonalBackwardPossibleHumanPlayStr = "";
//
//			//string negativeDiagonalStrWithoutExtraPiece = ""; // (\)
//			string negativeDiagonalStr = ""; // (\)
//			string negativeDiagonalForwardStr = "";
//			string negativeDiagonalBackwardStr = "";
//
//			string negativeDiagonalPossibleHumanPlayStr = ""; // (\)
//			string negativeDiagonalForwardPossibleHumanPlayStr = "";
//			string negativeDiagonalBackwardPossibleHumanPlayStr = "";
//
//			vector <double> points = vector <double>(numC, 0);
//
//
//
//			//VerticalSTR
//			for (int col = 0; col < numC; col++)
//			{
//
//				if (topline.at(col) != -1) // -1 -> column full
//				{
//					test_board.at(topline.at(col)).at(col) = ComputerSymbol;
//					test_board_possible_human_play.at(topline.at(col)).at(col) = HumanSymbol;
//
//					for (int lin = 0; lin < numL; lin++)
//					{
//						verticalStr = verticalStr + test_board.at(lin).at(col);
//						verticalPossibleHumanPlayStr = verticalPossibleHumanPlayStr + test_board_possible_human_play.at(lin).at(col);
//
//					}
//
//
//
//					for (int i = 0; i < all_combinations_computer.size(); i++)
//					{
//
//						if (verticalStr.find(all_combinations_computer.at(i)) != NotFoundInStr)
//						{
//							counting_points = count(verticalStr.begin(), verticalStr.end(), all_combinations_computer.at(i));
//							counting_symbols = count(all_combinations_computer.at(i).begin(), all_combinations_computer.at(i).end(), ComputerSymbol);
//							if (counting_symbols == winnerSequenceLength)
//								counting_symbols = 9000;
//
//							points[col] += counting_points * counting_symbols;
//
//						}
//
//						if (verticalStr.find(all_combinations_human.at(i)) != NotFoundInStr)
//						{
//							counting_points = count(verticalPossibleHumanPlayStr.begin(), verticalPossibleHumanPlayStr.end(), all_combinations_human.at(i));
//							counting_symbols = count(all_combinations_human.at(i).begin(), all_combinations_human.at(i).end(), HumanSymbol);
//							if (counting_symbols == winnerSequenceLength)
//								counting_symbols += 100;
//
//							points[col] += (counting_points * 0.66) * counting_symbols; // incentiva o computador a interromper jogadas do adversário.
//
//						}
//
//					}
//					verticalStr = "";
//					test_board.at(topline.at(col)).at(col) = emptySymbol;
//					test_board_possible_human_play.at(topline.at(col)).at(col) = emptySymbol;
//
//				}
//
//				else
//					points[col] = -1000;
//
//			}
//
//
//			//HorizontalSTR
//			for (int col = 0; col < numC; col++)
//			{
//
//				if (topline.at(col) != -1) // -1 -> column full
//				{
//					test_board.at(topline.at(col)).at(col) = ComputerSymbol;
//					test_board_possible_human_play.at(topline.at(col)).at(col) = HumanSymbol;
//
//
//
//					for (int col1 = 0; col1 < numC; col1++)
//					{
//
//						horizontalStr = horizontalStr + test_board.at(topline.at(col)).at(col1);
//						horizontalPossibleHumanPlayStr = horizontalPossibleHumanPlayStr + test_board_possible_human_play.at(topline.at(col)).at(col1);
//					}
//
//
//
//					for (int i = 0; i < all_combinations_computer.size(); i++)
//					{
//
//						if (horizontalStr.find(all_combinations_computer.at(i)) != NotFoundInStr)
//						{
//							counting_points = count(horizontalStr.begin(), horizontalStr.end(), all_combinations_computer.at(i));
//							counting_symbols = count(all_combinations_computer.at(i).begin(), all_combinations_computer.at(i).end(), ComputerSymbol);
//							if (counting_symbols == winnerSequenceLength)
//								counting_symbols = 9000;
//
//							points[col] += counting_points * counting_symbols;
//						}
//
//						if (horizontalPossibleHumanPlayStr.find(all_combinations_human.at(i)) != NotFoundInStr)
//						{
//							counting_points = count(horizontalPossibleHumanPlayStr.begin(), horizontalPossibleHumanPlayStr.end(), all_combinations_human.at(i));
//							counting_symbols = count(all_combinations_human.at(i).begin(), all_combinations_human.at(i).end(), HumanSymbol);
//							if (counting_symbols == winnerSequenceLength)
//								counting_symbols += 100;
//
//							points[col] += (counting_points * 0.66) * counting_symbols; // incentiva o computador a interromper jogadas do adversário.
//						}
//
//					}
//					horizontalStr = horizontalPossibleHumanPlayStr = "";
//					test_board.at(topline.at(col)).at(col) = emptySymbol;
//					test_board_possible_human_play.at(topline.at(col)).at(col) = emptySymbol;
//
//
//
//				}
//
//				else
//					points[col] = -1000;
//
//			}
//
//
//			//positiveDiagonalStr
//			for (int col = 0; col < numC; col++)
//			{
//
//				if (topline.at(col) != -1) // -1 -> column full
//				{
//					test_board.at(topline.at(col)).at(col) = ComputerSymbol;
//					test_board_possible_human_play.at(topline.at(col)).at(col) = HumanSymbol;
//
//					positiveDiagonalForwardStr = positiveDiagonalForwardStr + test_board.at(topline.at(col)).at(col);
//					positiveDiagonalForwardPossibleHumanPlayStr = positiveDiagonalForwardPossibleHumanPlayStr + test_board_possible_human_play.at(topline.at(col)).at(col);
//
//					for (int i = 1; i < HighestDimension; i++)
//					{
//						if ((col + i < numC) && (topline.at(col) - i > 0))
//						{
//							positiveDiagonalForwardStr = positiveDiagonalForwardStr + test_board.at((topline.at(col) - i)).at(col + i);
//							positiveDiagonalForwardPossibleHumanPlayStr = positiveDiagonalForwardPossibleHumanPlayStr + test_board_possible_human_play.at((topline.at(col) - i)).at(col + i);
//						}
//
//						if ((col - i > 0) && (topline.at(col) + i < numL))
//						{
//							positiveDiagonalBackwardStr = positiveDiagonalBackwardStr + test_board.at((topline.at(col) + i)).at(col - i);
//							positiveDiagonalBackwardPossibleHumanPlayStr = positiveDiagonalBackwardPossibleHumanPlayStr + test_board_possible_human_play.at((topline.at(col) + i)).at(col - i);
//						}
//
//					}
//
//					reverse(positiveDiagonalBackwardStr.begin(), positiveDiagonalBackwardStr.end());
//
//					reverse(positiveDiagonalBackwardPossibleHumanPlayStr.begin(), positiveDiagonalBackwardPossibleHumanPlayStr.end());
//
//					positiveDiagonalStr = positiveDiagonalBackwardStr + positiveDiagonalForwardStr;
//					positiveDiagonalPossibleHumanPlayStr = positiveDiagonalBackwardPossibleHumanPlayStr + positiveDiagonalForwardPossibleHumanPlayStr;
//
//
//
//					for (int i = 0; i < all_combinations_computer.size(); i++)
//					{
//
//						if (positiveDiagonalStr.find(all_combinations_computer.at(i)) != NotFoundInStr)
//						{
//							counting_points = count(positiveDiagonalStr.begin(), positiveDiagonalStr.end(), all_combinations_computer.at(i));
//							counting_symbols = count(all_combinations_computer.at(i).begin(), all_combinations_computer.at(i).end(), ComputerSymbol);
//							if (counting_symbols == winnerSequenceLength)
//								counting_symbols = 1000;
//
//							points[col] += counting_points * counting_symbols;
//
//						}
//
//						if (positiveDiagonalPossibleHumanPlayStr.find(all_combinations_human.at(i)) != NotFoundInStr)
//						{
//							counting_points = count(positiveDiagonalPossibleHumanPlayStr.begin(), positiveDiagonalPossibleHumanPlayStr.end(), all_combinations_computer.at(i));
//							counting_symbols = count(all_combinations_computer.at(i).begin(), all_combinations_computer.at(i).end(), HumanSymbol);
//							if (counting_symbols == winnerSequenceLength)
//								counting_symbols += 100;
//
//							points[col] += (counting_points * 0.66) * counting_symbols; // incentiva o computador a interromper jogadas do adversário.
//
//						}
//
//					}
//					positiveDiagonalStr = positiveDiagonalBackwardStr = positiveDiagonalForwardStr = "";
//					positiveDiagonalPossibleHumanPlayStr = positiveDiagonalBackwardPossibleHumanPlayStr = positiveDiagonalForwardPossibleHumanPlayStr = "";
//
//					test_board.at(topline.at(col)).at(col) = emptySymbol;
//					test_board_possible_human_play.at(topline.at(col)).at(col) = emptySymbol;
//
//				}
//
//				else
//					points[col] = -1000;
//			}
//
//
//			//negativeDiagonalStr
//			for (int col = 0; col < numC; col++)
//			{
//
//				if (topline.at(col) != -1) // -1 -> column full
//				{
//					test_board.at(topline.at(col)).at(col) = ComputerSymbol;
//					test_board_possible_human_play.at(topline.at(col)).at(col) = HumanSymbol;
//
//					negativeDiagonalForwardStr = negativeDiagonalForwardStr + test_board.at(topline.at(col)).at(col);
//					negativeDiagonalForwardPossibleHumanPlayStr = negativeDiagonalForwardPossibleHumanPlayStr + test_board_possible_human_play.at(topline.at(col)).at(col);
//
//					for (int i = 1; i < HighestDimension; i++)
//					{
//						if ((col - i > 0) && (topline.at(col) - i > 0))
//						{
//							negativeDiagonalForwardStr = negativeDiagonalForwardStr + test_board.at((topline.at(col) - i)).at(col + i);
//							negativeDiagonalForwardPossibleHumanPlayStr = negativeDiagonalForwardPossibleHumanPlayStr + test_board_possible_human_play.at((topline.at(col) - i)).at(col + i);
//						}
//
//						if ((col + i < numC) && (topline.at(col) + i < numL))
//						{
//							negativeDiagonalBackwardStr = negativeDiagonalBackwardStr + test_board.at((topline.at(col) + i)).at(col - i);
//							negativeDiagonalBackwardPossibleHumanPlayStr = negativeDiagonalBackwardPossibleHumanPlayStr + test_board_possible_human_play.at((topline.at(col) + i)).at(col - i);
//						}
//
//					}
//
//					reverse(negativeDiagonalBackwardStr.begin(), negativeDiagonalBackwardStr.end());
//
//					reverse(negativeDiagonalBackwardPossibleHumanPlayStr.begin(), negativeDiagonalBackwardPossibleHumanPlayStr.end());
//
//					negativeDiagonalStr = negativeDiagonalBackwardStr + negativeDiagonalForwardStr;
//					negativeDiagonalPossibleHumanPlayStr = negativeDiagonalBackwardPossibleHumanPlayStr + negativeDiagonalForwardPossibleHumanPlayStr;
//
//
//
//
//					for (int i = 0; i < all_combinations_computer.size(); i++)
//					{
//
//						if (negativeDiagonalStr.find(all_combinations_computer.at(i)) != NotFoundInStr)
//						{
//							counting_points = count(negativeDiagonalStr.begin(), negativeDiagonalStr.end(), all_combinations_computer.at(i));
//							counting_symbols = count(all_combinations_computer.at(i).begin(), all_combinations_computer.at(i).end(), ComputerSymbol);
//							if (counting_symbols == winnerSequenceLength)
//								counting_symbols = 1000;
//
//							points[col] += counting_points * counting_symbols;
//
//						}
//
//						if (negativeDiagonalPossibleHumanPlayStr.find(all_combinations_human.at(i)) != NotFoundInStr)
//						{
//							counting_points = count(negativeDiagonalPossibleHumanPlayStr.begin(), negativeDiagonalPossibleHumanPlayStr.end(), all_combinations_computer.at(i));
//							counting_symbols = count(all_combinations_computer.at(i).begin(), all_combinations_computer.at(i).end(), HumanSymbol);
//							if (counting_symbols == winnerSequenceLength)
//								counting_symbols += 100;
//
//							points[col] += (counting_points * 0.66) * counting_symbols; // incentiva o computador a interromper jogadas do adversário.
//
//						}
//
//					}
//					negativeDiagonalStr = negativeDiagonalBackwardStr = negativeDiagonalForwardStr = "";
//					negativeDiagonalPossibleHumanPlayStr = negativeDiagonalBackwardPossibleHumanPlayStr = negativeDiagonalForwardPossibleHumanPlayStr = "";
//
//					test_board.at(topline.at(col)).at(col) = emptySymbol;
//					test_board_possible_human_play.at(topline.at(col)).at(col) = emptySymbol;
//
//				}
//
//				else
//					points[col] = -1000;
//			}
//
//
//			int max_index = *max_element(points.rbegin(), points.rend()); // finds the index of the highest value in the vector points
//
//			board.at(topline.at(max_index)).at(max_index) = ComputerSymbol;
//
//
//
//
//
//
//		}
//
//
//
//
//
//
//
//
//
//		}
//
//
//	}
//
//}







*/
