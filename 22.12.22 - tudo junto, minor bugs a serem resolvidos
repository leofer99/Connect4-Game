#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <fstream> // allows to read and write .txt files
#include <cmath>
#include <iomanip>
#include <cstddef>
#include <csignal>
#include <cstdio>
#include <ctime> // Biblioteca tempo
#include <string>
#include <cctype>
#include <vector>
#include <sstream>
#include <algorithm>
#include <set>
//#include <unistd.h> //for usleep in linux 
#include <windows.h> //for sleep in windows

#define RESET   "\033[0m"
#define RED     "\033[31m"      /* Red */
#define BLUE    "\033[34m"

using namespace std;

//----------------------------------------------------------------------------------------------------
class player
{
public:
	player(int player_number, string symbol, string player_type);
	void InputName();
	string GetName();
	int GetNumber();
	string GetSymbol();
	string GetColour();
	string GetPlayerType();
	void SetPlayerType(string type);

private:
	int player_number; // 1 or 2
	string name;
	string symbol; // 'X' or 'O'
	string colour; // 'red' or 'blue'
	string player_type; // "Human", "Computer_Easy", "Computer_Medium", "Computer_Hard"
	//int N_in_line
};
//----------------------------------------------------------------------------------------------------
player::player(int player_number, string symbol, string player_type)
{
	this->player_number = player_number;
	this->symbol = symbol;
	this->player_type = player_type;
	this->name = "";

	if (symbol == "X")
		this->colour = "red";
	else if (symbol == "O")
		this->colour = "blue";
}
//----------------------------------------------------------------------------------------------------
void player::InputName()
{
	if (this->player_type == "Human")
	{
		int ID = this->player_number;
		cout << "\nPlayer" << ID << ", write your name: ";
		cin >> this->name;
		cout << "\nPlayer" << ID << ":" << this->name << endl;
	}

	else
	{
		this->name = this->player_type;
		cout << "\nPlayer" << this->player_number << ":" << this->name << endl;
	}

}
//----------------------------------------------------------------------------------------------------
int player::GetNumber()
{
	return this->player_number;
}
//---------------------------------------------------------------------------------------
string player::GetColour()
{
	return this->colour;
}
//---------------------------------------------------------------------------------------
string player::GetSymbol()
{
	return this->symbol;
}
//---------------------------------------------------------------------------------------
string player::GetName()
{
	return this->name;
}
//---------------------------------------------------------------------------------------
string player::GetPlayerType()
{
	return this->player_type;
}
//---------------------------------------------------------------------------------------
void player::SetPlayerType(string type)
{
	this->player_type = type;
}
//-----------------------------------------------------------------------------------------------
player Menu(player Enemy_player)
{
	string GameMode = "";
	string PlayerVSPlayer = "1";
	string PlayerVSComputer = "2";
	string AI_Easy = "1";
	string AI_Medium = "2";
	string AI_Hard = "3";

	//1st Part: Choose the type of Game Mode
	while (true)
	{
		cout << "How many people are playing?\n(1-Player VS Computer | 2-Player VS Player): ";
		cin >> GameMode;
		cout << endl;

		if (GameMode == PlayerVSPlayer)
		{
			Enemy_player.SetPlayerType("Computer_Easy");
			break;
		}
		else if (GameMode == PlayerVSComputer)
		{
			Enemy_player.SetPlayerType("Human");
			break;
		}
		else
			cout << "Error! You must input 1 or 2." << endl;
	}

	//2nd Part: Select Game Difficulty, in case of Player VS Computer
	if (Enemy_player.GetPlayerType() != "Human")
		while (true)
		{
			cout << "How difficult do you want the game to be?\n(1-Easy | 2-Medium | 3-Hard) ";
			cin >> GameMode;

			if (GameMode == AI_Easy)
			{
				Enemy_player.SetPlayerType("Computer_Easy");
				break;
			}

			else if (GameMode == AI_Medium)
			{
				Enemy_player.SetPlayerType("Computer_Medium");
				break;
			}

			else if (GameMode == AI_Hard)
			{
				Enemy_player.SetPlayerType("Computer_Hard");
				break;
			}

			else
				cout << "Error! You must input 1 , 2 or 3." << endl;
		}

	return Enemy_player;

}

//----------------------------------------------------------------------------------------------------
/**
*Class Board represents the board of the game, allowing to define the board limits, and place the disc on the column chosen with the respective player's color
*/
class Board
{
private:
	//representa a linha vazia mais baixa (para jogar nessa quando for escolhida essa coluna, para não ter de procurar nas linhas acima)
	vector <char> ColumnLegend;
	vector< vector<string>> board;
	//vector< vector<string>> test_board;
	int numL, numC, numN;
	string emptySymbol; //flexibilidade do que é considerado espaço vazio no tabuleiro.
	int numEmptyCells; //(fica - 1 a cada jogada.Ao chegar a zero, declara empate se ninguém tiver dado.)
	string headline;
	string winnerSequence1;
	string winnerSequence2;
	int NumberOfBoardCells = numC * numL;
	int HighestDimension = max(numC, numL);
	int LowestDimension = min(numL, numC);

	//Guardar linha e coluna da última jogada(procurar se há vencedor, apartir dessa posição)
	string LastDiscSymbol;
	//int ColumnSelected;
	int AI_selectedColumn;
	//Guardar LastDiscSymbol(procurar apenas o caráter do último vencedor)

public:
	//public variables
	vector <int> topline;
	int LastLinePlayed, LastColumnPlayed;

	Board(int numL, int numC, string emptySymbol, int winnersequencelength);
	void SetEmptySymbol();
	int GetNumLines() const;
	int GetNumColumns() const;
	string	GetEmptySymbol() const;
	void Headline() const;
	int	GetTopLineIndexAtColumn();
	//int SetTopLine() const;
	int SelectColumn(player player) const;
	void putDiscAtColumn(player player); //numa determinada coluna
	string isFull(int NumberOfPlays, int NumberOfBoardCells) const; //testar se board está cheio
	void show() const; //mostrar board
	string isThereAWinner(); //símbolo do vencedor, e linha e coluna da última jogada.
	void wouldThereBeAWinner(); //putDisc + winner? (p/ AI) 
	//(pode estar numa classe complementar - Classe Game : encarregar - se de ver conteúdo, verificar vencedor
	void AIPlay(int selectedColumn, string AIlevel);


};
//--------------------------------------------------------------------------------------
Board::Board(int numL, int numC, string emptySymbol, int winnersequencelength)
{
	this->numL = numL;
	this->numC = numC;
	this->emptySymbol = emptySymbol;
	string winnerSequence1(numN, 'X');
	string winnerSequence2(numN, 'O');
	this->winnerSequence1 = winnerSequence1;
	this->winnerSequence2 = winnerSequence2;
	this->topline = vector<int>(numC, numL - 1);
	this->board = vector <vector<string>>(numL, vector<string>(numC, emptySymbol));
}
//--------------------------------------------------------------------------------------
void Board::SetEmptySymbol()
{ //default empty symbol is '.'
	int choose_emptysymbol;
	cout << "Choose the empty symbol you would prefer to see: 1.'.', 2.[], 3._" << endl;
	cin >> choose_emptysymbol;

	string emptySymbol;

	switch (choose_emptysymbol)
	{
	case (1):
		emptySymbol = ".";
	case(2):
		emptySymbol = "[]";
	case (3):
		emptySymbol = "_";
	case (4):
		;
		//Player chooses emptySymbol
	default:
		emptySymbol = ".";
	};
}
//--------------------------------------------------------------------------------------
int Board::GetNumLines() const
{
	return this->numL;
}
//--------------------------------------------------------------------------------------
int Board::GetNumColumns() const
{
	return this->numC;
}
//--------------------------------------------------------------------------------------
string Board::GetEmptySymbol() const
{
	return this->emptySymbol;
}
//----------------------------------------------------------------------------------------------------
int Board::GetTopLineIndexAtColumn()
{ /* Function used to find the line where the disc will be placed.
At the start of the game, topline has numC elements equal to numL-1. Every time a disc is inserted,
the value saved for that corresponding column decreases by 1. Hence, if we play in the same column again, we will play in a line higher by 1,
When the value is 0, it will play at the top of the column. When the value is -1, the column is full.
*/
// after every play: 
	int ColumnHeight = topline.at(LastColumnPlayed);
	this->LastLinePlayed = ColumnHeight - 1;
	topline.at(LastColumnPlayed) = this->LastLinePlayed;
	return this->LastLinePlayed;
}

//-----------------------------------------------------------------------------------------------
int Board::SelectColumn(player player) const
{
	string InputedColumn = "";
	//const string alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	string PlayerName = player.GetName();
	string PlayerType = player.GetPlayerType();
	int Not_found = -1;
	int PossibleColumnSelected = -1;
	string IsColumnValid = "Invalid";

	if ((PlayerType == "Human"))
	{
		while (IsColumnValid == "Invalid")
		{
			cout << "\n" << PlayerName << ", in which column, do you want to insert your piece?" << endl;
			cin >> InputedColumn;


			if ((InputedColumn.size() != 1) || (int(InputedColumn[0]) > int('z'))) // garante que o input é somente uma letra
				InputedColumn = "_"; //in this case, it will not detect the value in the headline and will output an error

			if (int(InputedColumn[0]) > int('Z')) // garante que as minúusculas sejam convertidas em maiúsculas
				InputedColumn[0] = char(int(InputedColumn[0]) - 32);

			PossibleColumnSelected = int(headline.find(InputedColumn[0]));

			if (PossibleColumnSelected == Not_found) // garante que o inputed_column averiguado encontra-se na headline
				cout << "\nError! You must insert a valid input." << endl;

			else //if the value is valid
			{
				int ColumnHeight = topline.at(PossibleColumnSelected);
				if (ColumnHeight <= -1) //if top is reached, must play another column.
					cout << "\nAttention! Column is full, choose another." << endl;

				else //column is valid, while loop stops
					IsColumnValid = "Valid";
			}
		}
	}
	else //when the player_type is AI
		PossibleColumnSelected = AI_selectedColumn;

	int LastColumnPlayed = PossibleColumnSelected;

	return LastColumnPlayed;
}
//-----------------------------------------------------------------------------------------------
void Board::putDiscAtColumn(player player)
{	//works for both AI and Player

	this->LastColumnPlayed = LastColumnPlayed;
	this->LastLinePlayed = GetTopLineIndexAtColumn();
	this->LastDiscSymbol = player.GetSymbol();
	board.at(LastLinePlayed).at(LastColumnPlayed) = LastDiscSymbol;
}
//-----------------------------------------------------------------------------------------------
string Board::isFull(int NumberOfPlays, int NumberOfBoardCells) const
{
	string isThereATie = "There is no tie";

	if (NumberOfPlays == NumberOfBoardCells)
		isThereATie = "It's a Tie!";

	return isThereATie;
}
//-----------------------------------------------------------------------------------------------
void Board::Headline() const
{
	const string alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	string headline = alphabet.substr(0, GetNumColumns() - 1); //creates substring, according to the number of columns in the board. 
	this->headline;
}
//-----------------------------------------------------------------------------------------------
void Board::show() const
{
	//string line = "";
	//for (int i = 0; i<numL; i++)
	//{
	//	line = line + board[i];
	//}
	//cout << '\n';

	cout << headline << endl;;

	for (int col = 0; col < numC; col++) //outputs board
		for (int lin = 0; lin < numL; lin++)
		{
			if (col == numC - 1) //if it's a value in the last column, goes to the next line
				cout << ' ' << board.at(col).at(lin) << endl;
			else
				cout << ' ' << board.at(col).at(lin) << ' ';
		}

	cout << headline << endl;;

}
//-----------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------
string Board::isThereAWinner() 
{
	//checking for horizontal win:
	string lineWin = "";
	//for (int lin = 0; lin < GetNumLines() - 1; lin++)

	int possibleHorizontalWins = 0;
	int possibleVerticalWins = 0;
	int possibleNegativeDiagonalWins = 0; // (\)
	int possiblePositiveDiagonalWins = 0; // (/)
	string linWin = "";
	string ColWin = "";
	string NegativeDiagonalWin = "";// (\)
	string PositiveDiagonalWin = "";// (/)

	int NotFoundInStr = string::npos;

	// Iterator for each vector inside the 2-D vector
	vector<string>::const_iterator horizontal_it;

	//horizontal_it = board[lin].begin();

		// Vitória horizontal
	for (int lin = 0; lin < numL; lin++)
	{
		for (horizontal_it = board[lin].begin(); horizontal_it != board[lin].end(); horizontal_it++)
		{
			HighestDimension = 1;
			linWin = linWin + *horizontal_it;
			if (linWin.find(winnerSequence1) == NotFoundInStr)
				possibleHorizontalWins += 0;
			else
				possibleHorizontalWins += 1;

			if ((linWin.find(winnerSequence2) == NotFoundInStr) && (possibleHorizontalWins < 1))
				possibleHorizontalWins += 0;
			else if (possibleHorizontalWins < 1)
				possibleHorizontalWins += -1;

		}
		//cout << "\n\n" << linWin << endl;
		linWin = ""; //cleaning after each iteration
	}

	// Iterator for the 2-D vector
	vector<vector<string>>::const_iterator vertical_it;

	vector<string> boardLine;
	boardLine = vector <string>(numC, "");

	// Vitória vertical
	for (int col = 0; col < numC; col++)
	{
		for (vertical_it = board.begin(); vertical_it != board.end(); vertical_it++)
		{
			boardLine = *vertical_it; //analyses each line of the board and takes the 1st element, forming the 1st column. Keeps going for every column. 
			ColWin = ColWin + boardLine.at(col);
			if (ColWin.find(winnerSequence1) == NotFoundInStr)
				possibleVerticalWins += 0;
			else
				possibleVerticalWins += 1;

			if ((ColWin.find(winnerSequence2) == NotFoundInStr) && (possibleVerticalWins < 1))
				possibleVerticalWins += 0;
			else if (possibleVerticalWins < 1)
				possibleVerticalWins += -1;

		}
		ColWin = ""; //cleaning
	}

	//PositiveDiagonalWin PossiblePositiveDiagonalWin
	// Vitória diagonalLeftToRight (/)

	for (int col = 0; col < numC; col++)
	{
		for (int lin = 0; lin < numL; lin++)
		{
			for (int i = 0; i < HighestDimension; i++)
			{
				if ((lin + i < numL) && (col + i < numC))
					PositiveDiagonalWin = PositiveDiagonalWin + board.at(lin + i).at(col + i);
				else
					break;
			}

			if (PositiveDiagonalWin.find(winnerSequence1) != NotFoundInStr) //if we find player1 win 
				possiblePositiveDiagonalWins += 1;

			else if ((PositiveDiagonalWin.find(winnerSequence2) != NotFoundInStr) && (possibleVerticalWins < 1)) //if we find player2 win
				possiblePositiveDiagonalWins += -1;

			PositiveDiagonalWin = "";
		}
	}

	//NegativeDiagonalWin possibleNegativeDiagonalWin
	// Vitória diagonalRightToLeft (\)

	for (int col = 0; col < numC; col++)
	{
		for (int lin = 0; lin < numL; lin++)
		{
			for (int i = 0; i < HighestDimension; i++)
			{
				if ((lin + i < numL) && (col - i >= 0))
				{
					NegativeDiagonalWin = NegativeDiagonalWin + board.at(lin + i).at(col - i);
				}
				else
					break;
			}

			if (NegativeDiagonalWin.find(winnerSequence1) != NotFoundInStr)
				possibleNegativeDiagonalWins += 1;

			else if ((PositiveDiagonalWin.find(winnerSequence2) != NotFoundInStr) && (possibleVerticalWins < 1))
				possibleNegativeDiagonalWins += -1;

			NegativeDiagonalWin = "";
		}
	}

	string winner = "";

	if (possibleNegativeDiagonalWins < 0 || possiblePositiveDiagonalWins < 0 || possibleVerticalWins < 0 || possibleHorizontalWins < 0)
	{
		winner = "Player2";
		return winner;
	}


	else if (possibleNegativeDiagonalWins > 0 || possiblePositiveDiagonalWins > 0 || possibleVerticalWins > 0 || possibleHorizontalWins > 0)
	{
		winner = "Player1";
		return winner;
	}

	else
	{
		winner = "";
		return winner;
	}

}
//-----------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------
void Board::wouldThereBeAWinner()
{
	vector < vector <string> > test_board = board;

	for (int col = 0; col < numC; col++)
	{
		int lin = GetTopLineIndexAtColumn();
		test_board.at(lin).at(col) = "X";
		//string isThereAWinnerResult= isThereAWinner(test_board);
	}
}
//-----------------------------------------------------------------------------------------------
void Board::AIPlay(int selectedColumn, string AIlevel)
{
	//wouldThereBeAWinner(); playerSymbol = "O"

	//vector < vector <string> > test_board = board;
	Board test_board = Board(numL, numC, emptySymbol, numN);

	int HighestDimension = max(numC, numL);
	double counting_points = 0;
	double counting_symbols = 0;
	string winner = ""; // "Player1", "Player2" or "".
	int NotFoundInStr = string::npos;

	string ComputerSymbol = "O";
	string HumanSymbol = "X";
	string emptySymbolStr = "";
	bool change = false;


	// AI Easy - Places pieces randomly.
	if (AIlevel == "Computer_Easy")
	{
		// AI_move = min + (rand() % (int)(max - min + 1)) / min=0 e max=numC
		int AI_move = rand() % (int)(numC + 1); //random number between 0 and numC

		test_board.board.at(topline.at(AI_move)).at(AI_move) = "O";
		//string symbol= "O";
		test_board.board.at(topline.at(AI_move)).at(AI_move) = "O";
		board = test_board.board; // erro?
	}

	// AI Medium - Plays most of the time randomly, except when the AI can get a win or stop the opponent for winning. 
	else if (AIlevel == "Computer_Medium")
	{
		// Insert a piece in every column of the test_board, a copy of the original board.
		for (int i = 0; i < numC; i++)
		{
			test_board.board.at(topline.at(i)).at(i) = "O";
			winner = test_board.isThereAWinner();
			test_board.board.at(topline.at(i)).at(i) = emptySymbol;

			if (winner == "Player2")
				board.at(topline.at(i)).at(i) = "O"; break; // erro?

			test_board.board.at(topline.at(i)).at(i) = "X";
			winner = test_board.isThereAWinner();
			test_board.board.at(topline.at(i)).at(i) = emptySymbol;

			if (winner == "Player1")
				board.at(topline.at(i)).at(i) = "O"; break; // erro?
		}
	}

}
//-----------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------
/*End of Class player.
Start of Functions to help play the game*/
//-----------------------------------------------------------------------------------------------
int SetNumLines()
{
	int numL = 0;
	while (numL < 6 || numL > 10)
	{
		cout << "Please, set the dimensions of the board (Minimum dimension: 6x6, Maximum dimension: 10x10). Number of Lines: ";
		cin >> numL;
		if (numL < 6 || numL > 10)
		{
			cout << "Invalid Number of Lines, must be between 6 and 10!! \n";
		}
	}
	return numL;
}
//-----------------------------------------------------------------------------------------------
int SetNumColumns()
{
	int numC=0;
	while (numC < 6 || numC > 10)
	{
		cout << "Number of Columns: ";
		cin >> numC;
		if (numC < 6 || numC > 10)
		{
			cout << "Invalid Number of Columns, must be between 6 and 10!! \n";
		}
	}
	return numC;
}
//-----------------------------------------------------------------------------------------------
int SetConditionsForWinner(int numL, int numC)
{
	int numN=0;

	while (numN < 4 || numN> max(numC, numL))
	{
		cout << "Please, choose how many consecutive symbols are needed to win (Minimun = 4):  ";
		cin >> numN;

		if (numN < 4 || numN> max(numC, numL))
		{
			cout << "Invalid Condition!! \n";
		}
	}
	return numN;
}
//-----------------------------------------------------------------------------------------------
char time()
{
	time_t t;
	struct tm* infoTime;
	char DayTime[20]; //Where the time information will be saved.

	time(&t);
	infoTime = localtime(&t); //Get the time 

	strftime(DayTime, 20, "%F / %R", infoTime); //Creates the Day and Time with the following format YYYY/MM/DD / HH:MM

	return DayTime[20];
}
//-----------------------------------------------------------------------------------------------
void GameEnd(player player1, player player2, string winnerInfo)
{
	string ctrlz;
	if (ctrlz == "Not Pressed")
	{
		//if CTRL-Z is activated, nothing is registered in the file.
		//if it is not activated/pressed, data is registered in the file

		ofstream file;
		file.open("winner.txt");// Creates the file 

		// Writes the winner and the time in file in following format: 2022-10-15 / 09:05 – 1)computador vs 2)Pedro Costa – vencedor: 2.
		file << time();
		file << " - 1)" << player1.GetName() << " vs 2)" << player2.GetName() << " - vencedor: " << winnerInfo << "\n";
		file.close(); // Close file

		cout << "Saving to the file..." << endl;
		unsigned sleep(2); //Sleep the system for 2s 
		cout << "Thanks for playing, bye :) !! " << endl;

	}
}
//-----------------------------------------------------------------------------------------------
void Game()
{	//Players' Set-Up
	player player1 = player(1, "X", "Human");
	player player2 = player(2, "O", "Human");
	player2 = Menu(player2); //Menu() - asks player game mode, level of difficulty
	player1.InputName(); //asks players' name 
	player2.InputName();

	//Board Set-Up
	int numL = SetNumLines(); //user chooses board size
	int numC = SetNumColumns();
	int numN = SetConditionsForWinner(numL, numC); //user chooses winner length sequence

	string emptySymbol = ".";

	Board board = Board(numL, numC, emptySymbol, numN);

	board.SetEmptySymbol(); //user chooses empty symbol

	int NumberOfBoardCells = numL * numC;
	int NumberOfPlays = 0;
	string winnerInfo = {};
	string GameResult = "No Winner Yet";
	player playerPlaying = player1; //player1 starts
	string strPlayerPlaying = "player1";

	//Game Start
	while (true)
	{
		board.show(); //shows board with headline directly above and below
		int LastColumnPlayed = board.SelectColumn(playerPlaying); //player chooses column
		board.putDiscAtColumn(playerPlaying);
		NumberOfPlays = NumberOfPlays + 1;
		GameResult = board.isThereAWinner(); //tests if there is a winner

		if (GameResult == "IsWinner")
		{
			GameEnd(player1, player2, winnerInfo); //game ends
			break;
		}

		else //when there is no winner yet
		{
			string IsThereATie = board.isFull(NumberOfPlays, NumberOfBoardCells);

			if (IsThereATie == "It's a Tie!") //checks for tie
			{
				winnerInfo = "Empate, não há vencedor.";
				GameEnd(player1, player2, winnerInfo); //game ends
				break;
			}

			else //if there is no tie, game keeps going: players switch turns
			{
				if (strPlayerPlaying == "player1")
					//if (playerPlaying.GetNumber() == 1)
				{
					player1 = playerPlaying; //saves last play
					playerPlaying = player2; //switches player
					//strPlayerPlaying = "player2";
					break;
				}
				else if (strPlayerPlaying == "player2")
					//else if (playerPlaying.GetNumber() == 2)
				{
					player2 = playerPlaying; //saves last play
					playerPlaying = player1; //switches player
					strPlayerPlaying = "player1";
					break;
				}
			}
		}
	}
}
//-----------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------
int main()
{
	srand(unsigned(time(NULL)));
	Game();
	return 0;
}
